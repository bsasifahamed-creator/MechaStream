import { NextRequest, NextResponse } from 'next/server';
import fs from 'fs';
import path from 'path';

interface ProjectFile {
  path: string;
  content: string;
}

function slugifyProjectName(prompt: string): string {
  const lower = prompt.toLowerCase().trim();
  const match = lower.match(/(?:create|build|make)\s+(?:me\s+)?(?:a\s+)?([a-z0-9\s\-]+?)(?:\s+with\s|\s+website|\s+app|\s+site|\s+platform|\s+tool|\s+system|\s+page|$)/i);
  const base = match ? match[1].trim() : lower;
  const slug = base.replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '');
  const sanitized = slug || 'untitled-project';
  return sanitized.length > 40 ? sanitized.slice(0, 40) : sanitized;
}

function createFallbackFiles(prompt: string): ProjectFile[] {
  return [
    {
      path: 'backend/app.py',
      content: `from flask import Flask, render_template
from flask_cors import CORS

app = Flask(__name__)
CORS(app)

@app.route('/')
def index():
    return render_template('index.html')

if __name__ == '__main__':
    import os
    port = int(os.environ.get('FLASK_PORT', 5000))
    app.run(debug=True, port=port, host='0.0.0.0')
`,
    },
    {
      path: 'backend/templates/index.html',
      content: `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>${prompt.slice(0, 60)}</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}" />
</head>
<body>
  <div class="min-h-screen flex items-center justify-center bg-gray-100">
    <div class="text-center p-8">
      <h1 class="text-2xl font-bold text-gray-900">${prompt.slice(0, 60)}</h1>
      <p class="mt-2 text-gray-600">Generated by AI. Edit in the IDE.</p>
    </div>
  </div>
  <script src="{{ url_for('static', filename='script.js') }}"></script>
</body>
</html>
`,
    },
    {
      path: 'backend/static/style.css',
      content: '/* Styles */\nbody { margin: 0; font-family: system-ui, sans-serif; }\n',
    },
    {
      path: 'backend/static/script.js',
      content: "// JavaScript\ndocument.addEventListener('DOMContentLoaded', () => console.log('App loaded'));\n",
    },
    { path: 'backend/requirements.txt', content: 'flask==2.3.3\nflask-cors==4.0.0\n' },
  ];
}

/** Build project from template when Ollama is unavailable or returns no files. */
function buildFromTemplate(prompt: string): { projectName: string; files: ProjectFile[] } {
  return {
    projectName: slugifyProjectName(prompt),
    files: createFallbackFiles(prompt),
  };
}

const OLLAMA_TIMEOUT_MS = 30000; // 30s for Ollama
const OLLAMA_BASE_URL = process.env.OLLAMA_BASE_URL || 'http://localhost:11434';
const OLLAMA_CODE_MODEL = process.env.OLLAMA_CODE_MODEL || 'qwen3:4b';

/** Call Ollama directly for code generation (no self-fetch). Returns null on timeout/failure. */
async function tryGetFilesFromOllama(_baseUrl: string, prompt: string): Promise<{ projectName: string; files: ProjectFile[] } | null> {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), OLLAMA_TIMEOUT_MS);
  try {
    const res = await fetch(`${OLLAMA_BASE_URL}/api/generate`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        model: OLLAMA_CODE_MODEL,
        prompt: `You are an expert full-stack developer. Generate a complete web application. Output ONLY valid JSON: {"files": [{"path": "relative/path/to/file.ext", "content": "full file content"}]} - no markdown, no code blocks. Include backend: backend/app.py, backend/requirements.txt, backend/templates/index.html, backend/static/style.css, backend/static/script.js. Full working code only.

User request: ${prompt}`,
        stream: false,
        options: { temperature: 0.7, num_predict: 4000 },
      }),
      signal: controller.signal,
    });
    clearTimeout(timeoutId);
    if (!res.ok) {
      console.log('Generate: Ollama returned', res.status);
      return null;
    }
    const data = await res.json().catch(() => ({}));
    const content = (data.response || '').trim();
    if (!content) return null;
    let parsed: { files?: Array<{ path?: string; content?: string }> };
    try {
      const jsonMatch = content.match(/\{[\s\S]*\}/);
      parsed = jsonMatch ? JSON.parse(jsonMatch[0]) : JSON.parse(content);
    } catch {
      return null;
    }
    const files = Array.isArray(parsed?.files) ? parsed.files : null;
    if (!files || files.length === 0) return null;
    type FileLike = { path?: unknown; content?: unknown };
    const valid = (files as unknown[]).filter(
      (f: unknown): f is { path: string; content: string } =>
        typeof f === 'object' && f !== null && typeof (f as FileLike).path === 'string' && typeof (f as FileLike).content === 'string'
    );
    if (valid.length === 0) return null;
    return {
      projectName: slugifyProjectName(prompt),
      files: valid.map((f) => ({ path: f.path.replace(/^\/+/, ''), content: f.content })),
    };
  } catch (e) {
    clearTimeout(timeoutId);
    console.log('Generate: Ollama unavailable or timeout, using template:', e instanceof Error ? e.message : e);
    return null;
  }
}

/** Always use template so Build never hangs or fails. Ollama is skipped in critical path for reliability. */
function getProjectNameAndFiles(prompt: string): { projectName: string; files: ProjectFile[] } {
  const template = buildFromTemplate(prompt);
  const projectName = (template.projectName || '').replace(/[^a-z0-9\-]/gi, '').slice(0, 80) || 'untitled-project';
  return { projectName, files: template.files };
}

function writeProjectToDisk(projectName: string, files: ProjectFile[]): void {
  const cwd = process.cwd();
  const projectsRoot = path.resolve(cwd, 'projects');
  const projectDir = path.resolve(projectsRoot, projectName);
  if (!fs.existsSync(projectsRoot)) fs.mkdirSync(projectsRoot, { recursive: true });
  if (!fs.existsSync(projectDir)) fs.mkdirSync(projectDir, { recursive: true });
  let written = 0;
  for (const file of files) {
    const safePath = file.path.replace(/^\/+/, '').replace(/\.\./g, '').replace(/^[\\/]+/, '');
    if (!safePath) continue;
    const filePath = path.join(projectDir, safePath);
    const dir = path.dirname(filePath);
    const rel = path.relative(projectDir, filePath);
    if (rel.startsWith('..') || path.isAbsolute(rel)) continue;
    if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });
    fs.writeFileSync(filePath, file.content, 'utf-8');
    written++;
  }
  if (written === 0) throw new Error('No files were written');
}

/** 0.0.0.0 is invalid in browsers; use localhost for redirects. */
function redirectOrigin(req: NextRequest): string {
  const url = req.nextUrl;
  const host = url.hostname || '';
  if (host === '0.0.0.0') {
    const port = url.port || '3001';
    return `${url.protocol}//localhost:${port}`;
  }
  return url.origin;
}

export async function GET(req: NextRequest) {
  const prompt = req.nextUrl.searchParams.get('prompt')?.trim();
  const origin = redirectOrigin(req);
  if (!prompt) {
    return NextResponse.redirect(new URL('/?error=Please+enter+a+description', origin));
  }
  try {
    const { projectName, files } = getProjectNameAndFiles(prompt);
    writeProjectToDisk(projectName, files);
    const ideUrl = new URL(`/ide?project=${encodeURIComponent(projectName)}&prompt=${encodeURIComponent(prompt)}&openChat=1`, origin);
    return NextResponse.redirect(ideUrl);
  } catch (e) {
    console.error('Generate GET error:', e);
    return NextResponse.redirect(new URL('/?error=Build+failed', origin));
  }
}

export async function POST(req: NextRequest) {
  try {
    let body: { prompt?: string };
    try {
      body = await req.json();
    } catch {
      return NextResponse.json({ error: 'Invalid JSON body' }, { status: 400 });
    }
    const prompt = body?.prompt;
    if (!prompt || typeof prompt !== 'string') {
      return NextResponse.json({ error: 'Prompt is required' }, { status: 400 });
    }

    const { projectName, files } = getProjectNameAndFiles(prompt);
    writeProjectToDisk(projectName, files);

    return NextResponse.json({
      success: true,
      projectId: projectName,
      projectName,
      files: files.map((f) => f.path),
      message: `Project "${projectName}" created with ${files.length} files`,
    });
  } catch (unhandled: unknown) {
    const msg = unhandled instanceof Error ? unhandled.message : String(unhandled);
    console.error('Generate route unhandled:', unhandled);
    return NextResponse.json(
      { error: process.env.NODE_ENV === 'development' ? msg : 'Internal server error' },
      { status: 500 }
    );
  }
}
